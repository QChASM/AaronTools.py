#!/usr/bin/env python3
"""Generate and save prime numbers"""
import json

class Primes:
    """
    Class Attributes:
        CACHE       the default cache file for storing previously found primes
        verbose     bool for printing verbosity
    Instance Attributes:
        primes  the list of found prime numbers
    """
    cache = 'cache/primes.dat'
    clean = False
    verbose = False
    store_at = 500
    STORE_REFRESH = 20000000

    def __init__(self, cache=None, clean=None, verbose=None):
        if cache is not None:
            Primes.cache = cache
        if clean is not None:
            Primes.clean = clean
        if verbose is not None:
            Primes.verbose = verbose

        self.primes = [2, 3]  # a starting list in case there's no cache to read
        self.read_primes()
        return

    def print(self, n):
        """print first n primes"""
        if len(self.primes) < n:
            self.get_primes(n)
        s = "{:8d} "
        for i, p in enumerate(self.primes):
            if i > n:
                break
            print(s.format(p), end='')
            if i % 10 == 9:
                print()
        if i % 10 != 9:
            print()

    def read_primes(self):
        """read previously found primes from list"""
        if not Primes.clean:
            try:
                f = open(Primes.cache, 'r')
                self.primes = json.load(f)
                f.close()
                if Primes.verbose:
                    print("Primes loaded from cache:", self.primes)
            except json.decoder.JSONDecodeError:
                if Primes.verbose:
                    print("No cache found, starting from scratch")
                pass
        Primes.store_at = Primes.STORE_REFRESH // len(self.primes)

    def store_primes(self):
        """stores primes in cache as json"""
        with open(Primes.cache, 'w') as f:
            json.dump(self.primes, f)
            if Primes.verbose:
                print("Primes saved to cache")
        Primes.store_at = Primes.STORE_REFRESH // len(self.primes)
        return

    def __next__(self):
        """Generates the next prime number"""
        q = self.primes[-1] + 2  # all primes after 2 are odd
        while True:
            for p in self.primes:
                if q % p == 0:
                    q += 2
                    break
            else:
                if Primes.verbose:
                    print("Next prime found: ", q)
                return q

    def get_primes(self, n):
        """generates n prime numbers"""
        count = 0
        while len(self.primes) < n:
            count += 1
            self.primes += [next(self)]
            if count > Primes.store_at:
                # incrementally cache primes
                self.store_primes()
                count = 0
        # cache new primes
        self.store_primes()
        return

    def max_bound(self, n):
        """returns the largest prime less than n"""
        count = 0
        changed = False
        while self.primes[-1] < n:
            self.primes += [next(self)]
            changed = True
            count += 1
            if count > Primes.store_at:
                # incrementally save primes
                self.store_primes()
                count = 0
        if changed:
            # cache newly found primes
            self.store_primes()
        for i, p in enumerate(self.primes):
            if p > n:
                break
        return self.primes[i-1]


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser("For generating the first N prime numbers")
    parser.add_argument('N', type=int,
            help='The number of primes to return (or the max bound for --get)')
    parser.add_argument('--bound', '-b', action='store_true',
            help='Return the largest prime number less than N (instead of the first N prime numbers)')
    parser.add_argument('--cache', type=str,
            help='The cache file to use, instead of the default')
    parser.add_argument('--clean', action='store_true',
            help ='Clear the current cache file before prime generation')
    parser.add_argument('--verbose', '-v', action='store_true')

    args = parser.parse_args()
    primes = Primes(cache=args.cache, clean=args.clean, verbose=args.verbose)
    if args.bound:
        p = primes.max_bound(args.N)
        print(p)
    else:
        primes.get_primes(args.N)
        primes.print(args.N)
